<?xml version="1.0" encoding="UTF-8"?>
<package xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="PACK.xsd" schemaVersion="1.4">
  <name>MIMXRT1170-EVKB_MULTICORE_Examples</name>
  <vendor>NXP</vendor>
  <description>Middleware multicore Examples Pack for MIMXRT1170-EVKB</description>
  <url>https://mcuxpresso.nxp.com/cmsis_pack/repo/</url>
  <license>Licenses.txt</license>
  <releases>
    <release version="1.0.0" date="2024-01-14">NXP CMSIS SBSP Packs based on MCUXpresso SDK 2.15.0</release>
  </releases>
  <keywords>
    <keyword>Middleware Board Support Pack</keyword>
  </keywords>
  <requirements>
    <packages>
      <package name="MIMXRT1170-EVKB_BSP" vendor="NXP" version="18.0.0"/>
      <package name="MULTICORE" vendor="NXP" version="11.0.0"/>
      <package name="MIMXRT1176_DFP" vendor="NXP" version="18.0.0"/>
      <package name="CMSIS" vendor="ARM" version="5.8.0"/>
      <package name="FREERTOS-KERNEL" vendor="NXP" version="2.0.0"/>
    </packages>
    <languages>
      <language name="C" version="99"/>
    </languages>
  </requirements>
  <examples>
    <example name="erpc_matrix_multiply_mu_rtos_cm4" folder="boards/evkbmimxrt1170/multicore_examples/erpc_matrix_multiply_mu_rtos/cm4" doc="readme.md">
      <description>The Multicore eRPC Matrix Multiply RTOS project is a simple demonstration program that uses theMCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Callbetween cores of the multicore system. The primary core (eRPC client) releases the secondary core(eRPC server) from the reset and then the erpcMatrixMultiply() eRPC call is issued to let thesecondary core to perform the multiplication of two randomly generated matrices. The originalmatrices and the result matrix is printed out to the serial console by the primary core. Thematrix multiplication can be issued repeatedly when pressing a SW board button. MU (Messaging Unit)erpc transport layer is used in this example application.eRPC documentation eRPC specific files are stored in: middleware/multicore/erpc eRPC documentation is stored in: middleware/multicore/erpc/doc eRPC is open-source project stored on github: https://github.com/EmbeddedRPC/erpc eRPC documentation can be also found in: http://embeddedrpc.github.io</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_matrix_multiply_mu_rtos_cm4.uvprojx"/>
        <environment name="csolution" load="../erpc_matrix_multiply_mu_rtos.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="erpc_matrix_multiply_mu_cm4" folder="boards/evkbmimxrt1170/multicore_examples/erpc_matrix_multiply_mu/cm4" doc="readme.md">
      <description>The Multicore eRPC Matrix Multiply project is a simple demonstration program that uses theMCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Callbetween cores of the multicore system. The primary core (eRPC client) releases the secondary core(eRPC server) from the reset and then the erpcMatrixMultiply() eRPC call is issued to let thesecondary core to perform the multiplication of two randomly generated matrices. The originalmatrices and the result matrix is printed out to the serial console by the primary core. Thematrix multiplication can be issued repeatedly when pressing a SW board button. MU (Messaging Unit)erpc transport layer is used in this example application.eRPC documentation eRPC specific files are stored in: middleware/multicore/erpc eRPC documentation is stored in: middleware/multicore/erpc/doc eRPC is open-source project stored on github: https://github.com/EmbeddedRPC/erpc eRPC documentation can be also found in: http://embeddedrpc.github.io</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_matrix_multiply_mu_cm4.uvprojx"/>
        <environment name="csolution" load="../erpc_matrix_multiply_mu.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="erpc_matrix_multiply_rpmsg_rtos_cm4" folder="boards/evkbmimxrt1170/multicore_examples/erpc_matrix_multiply_rpmsg_rtos/cm4" doc="readme.md">
      <description>The Multicore eRPC Matrix Multiply RTOS project is a simple demonstration program that uses theMCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Callbetween cores of the multicore system. The primary core (eRPC client) releases the secondary core(eRPC server) from the reset and then the erpcMatrixMultiply() eRPC call is issued to let thesecondary core to perform the multiplication of two randomly generated matrices. The originalmatrices and the result matrix is printed out to the serial console by the primary core. Thematrix multiplication can be issued repeatedly when pressing a SW board button. RPMsg-Lite erpctransport layer is used in this example application.Shared memory usageThis multicore example uses the shared memory for data exchange. The shared memory region isdefined and the size can be adjustable in the linker file. The shared memory region start addressand the size have to be defined in linker file for each core equally. The shared memory startaddress is then exported from the linker to the application.eRPC documentationeRPC specific files are stored in: middleware/multicore_&lt;version&gt;/erpceRPC documentation is stored in: middleware/multicore_&lt;version&gt;/erpc/doceRPC is open-source project stored on github: https://github.com/EmbeddedRPC/erpceRPC documentation can be also found in: http://embeddedrpc.github.io</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_matrix_multiply_rpmsg_rtos_cm4.uvprojx"/>
        <environment name="csolution" load="../erpc_matrix_multiply_rpmsg_rtos.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="erpc_matrix_multiply_rpmsg_cm4" folder="boards/evkbmimxrt1170/multicore_examples/erpc_matrix_multiply_rpmsg/cm4" doc="readme.md">
      <description>The Multicore eRPC Matrix Multiply project is a simple demonstration program that uses theMCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Callbetween cores of the multicore system. The primary core (eRPC client) releases the secondary core(eRPC server) from the reset and then the erpcMatrixMultiply() eRPC call is issued to let thesecondary core to perform the multiplication of two randomly generated matrices. The originalmatrices and the result matrix is printed out to the serial console by the primary core. Thematrix multiplication can be issued repeatedly when pressing a SW board button. RPMsg-Lite erpctransport layer is used in this example application.Shared memory usageThis multicore example uses the shared memory for data exchange. The shared memory region isdefined and the size can be adjustable in the linker file. The shared memory region start addressand the size have to be defined in linker file for each core equally. The shared memory startaddress is then exported from the linker to the application.eRPC documentationeRPC specific files are stored in: middleware/multicore_&lt;version&gt;/erpceRPC documentation is stored in: middleware/multicore_&lt;version&gt;/erpc/doceRPC is open-source project stored on github: https://github.com/EmbeddedRPC/erpceRPC documentation can be also found in: http://embeddedrpc.github.io</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_matrix_multiply_rpmsg_cm4.uvprojx"/>
        <environment name="csolution" load="../erpc_matrix_multiply_rpmsg.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="erpc_two_way_rpc_rpmsg_rtos_cm4" folder="boards/evkbmimxrt1170/multicore_examples/erpc_two_way_rpc_rpmsg_rtos/cm4" doc="readme.md">
      <description>The Multicore eRPC Two Way RPC RTOS project is a simple demonstration program that uses the MCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Call between cores of the multicore system. This multicore example shows how both the eRPC client and the eRPC server can be setup on one side/core (bidirectional communication) and how to handle callback functions in eRPC. The primary core (Core0) creates client and server tasks first. The client task releases the secondary core from the reset, initializes the RPMsg-Lite erpc transport and once the server task is running it configures the arbitrated client. Then the application logic is running. The secondary core (Core1) creates client and server tasks two. The client task initializes the RPMsg-Lite erpc transport and once the server task is running it configures the arbitrated client. Then the application logic is running. The client task logic of the Core1 is very simple, it repeatedly calls the increaseNumber() erpc function that is implemented on the Core0 and that increments the counter. The client task logic of the Core0 alternately issues either getNumberFromCore0() function implementation on the Core0 or getNumberFromCore1() function implementation on the Core1 (erpc call). Then, the nestedCallGetNumber() erpc function call is issued that alternately triggers either getNumberFromCore1() function implementation on the Core1 (normal erpc call) or it triggers the getNumberFromCore0() function implementation on the Core0 (nested erpc call, routed through the Core1 erpc server).</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_two_way_rpc_rpmsg_rtos_cm4.uvprojx"/>
        <environment name="csolution" load="../erpc_two_way_rpc_rpmsg_rtos.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="freertos_message_buffers_cm4" folder="boards/evkbmimxrt1170/multicore_examples/freertos_message_buffers/cm4" doc="readme.md">
      <description>The FreeRTOS Message Buffers multicore project is a simple demonstration program that uses the MCUXpresso SDK software and the Message Buffers component of FreeRTOS. It shows how to implement lightweight core to core communication using FreeRTOS Message Buffers, which are lockless circular buffers that can pass data packets of varying sizes from a single sender to a single receiver. The primary core releases the secondary core from the reset and then the inter-core communication is established then. Once the Message Buffers are initialized on both cores the message exchange starts, incrementing a virtual counter that is part of the message payload. The message pingpong finishes when the counter reaches the value of 100. The Message Buffer is deinitialized at the end. NXP Multicore Manager (MCMGR) component is used for several purposes in this example: - it releases the secondary core from the reset (starts the secondary code) - it registers and use the application event for init handshaking (the secondary core application signals to the primary core it is ready to communicate) - it registers and use the FreeRtosMessageBuffersEvent for inter-core interrupts triggering and interrupts handling. Shared memory usage: This multicore example uses the shared memory for data exchange. The shared memory region is defined and the size can be adjustable in the linker file. The shared memory region start address and the size have to be defined in linker file for each core equally. The shared memory start address is then exported from the linker to the application to allow placing FreeRTOS Message Buffers at a fixed location that is then known for both cores.</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/freertos_message_buffers_cm4.uvprojx"/>
        <environment name="csolution" load="../freertos_message_buffers.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="hello_world_cm4" folder="boards/evkbmimxrt1170/multicore_examples/hello_world/cm4" doc="readme.md">
      <description>The Multicore Hello World demo application demonstrates how to set up projects for individualcores on a multicore system. In this demo, the primary core prints the "Hello World from the Primary Core!"string to the terminal and then releases the secondary core from the reset. The secondarycore toggles an on-board LED indicating that the secondary core is running.</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/hello_world_cm4.uvprojx"/>
        <environment name="csolution" load="../hello_world_multicore.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="rpmsg_lite_pingpong_rtos_cm4" folder="boards/evkbmimxrt1170/multicore_examples/rpmsg_lite_pingpong_rtos/cm4" doc="readme.md">
      <description>The Multicore RPMsg-Lite pingpong RTOS project is a simple demonstration program that uses theMCUXpresso SDK software and the RPMsg-Lite library and shows how to implement the inter-corecommunicaton between cores of the multicore system. The primary core releases the secondary corefrom the reset and then the inter-core communication is established. Once the RPMsg is initializedand endpoints are created the message exchange starts, incrementing a virtual counter that is partof the message payload. The message pingpong finishes when the counter reaches the value of 100.Then the RPMsg-Lite is deinitialized and the procedure of the data exchange is repeated again.Shared memory usageThis multicore example uses the shared memory for data exchange. The shared memory region isdefined and the size can be adjustable in the linker file. The shared memory region start addressand the size have to be defined in linker file for each core equally. The shared memory startaddress is then exported from the linker to the application.</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/rpmsg_lite_pingpong_rtos_cm4.uvprojx"/>
        <environment name="csolution" load="../rpmsg_lite_pingpong_rtos.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="rpmsg_lite_pingpong_cm4" folder="boards/evkbmimxrt1170/multicore_examples/rpmsg_lite_pingpong/cm4" doc="readme.md">
      <description>The Multicore RPMsg-Lite pingpong project is a simple demonstration program that uses theMCUXpresso SDK software and the RPMsg-Lite library and shows how to implement the inter-corecommunicaton between cores of the multicore system. The primary core releases the secondary corefrom the reset and then the inter-core communication is established. Once the RPMsg is initializedand endpoints are created the message exchange starts, incrementing a virtual counter that is partof the message payload. The message pingpong finishes when the counter reaches the value of 100.Then the RPMsg-Lite is deinitialized and the procedure of the data exchange is repeated again.Shared memory usageThis multicore example uses the shared memory for data exchange. The shared memory region isdefined and the size can be adjustable in the linker file. The shared memory region start addressand the size have to be defined in linker file for each core equally. The shared memory startaddress is then exported from the linker to the application.</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/rpmsg_lite_pingpong_cm4.uvprojx"/>
        <environment name="csolution" load="../rpmsg_lite_pingpong.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="erpc_matrix_multiply_mu_cm7" folder="boards/evkbmimxrt1170/multicore_examples/erpc_matrix_multiply_mu/cm7" doc="readme.md">
      <description>The Multicore eRPC Matrix Multiply project is a simple demonstration program that uses theMCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Callbetween cores of the multicore system. The primary core (eRPC client) releases the secondary core(eRPC server) from the reset and then the erpcMatrixMultiply() eRPC call is issued to let thesecondary core to perform the multiplication of two randomly generated matrices. The originalmatrices and the result matrix is printed out to the serial console by the primary core. Thematrix multiplication can be issued repeatedly when pressing a SW board button. MU (Messaging Unit)erpc transport layer is used in this example application.eRPC documentation eRPC specific files are stored in: middleware/multicore/erpc eRPC documentation is stored in: middleware/multicore/erpc/doc eRPC is open-source project stored on github: https://github.com/EmbeddedRPC/erpc eRPC documentation can be also found in: http://embeddedrpc.github.io</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_matrix_multiply_mu_cm7.uvprojx"/>
        <environment name="csolution" load="../erpc_matrix_multiply_mu.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="erpc_matrix_multiply_mu_rtos_cm7" folder="boards/evkbmimxrt1170/multicore_examples/erpc_matrix_multiply_mu_rtos/cm7" doc="readme.md">
      <description>The Multicore eRPC Matrix Multiply RTOS project is a simple demonstration program that uses theMCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Callbetween cores of the multicore system. The primary core (eRPC client) releases the secondary core(eRPC server) from the reset and then the erpcMatrixMultiply() eRPC call is issued to let thesecondary core to perform the multiplication of two randomly generated matrices. The originalmatrices and the result matrix is printed out to the serial console by the primary core. Thematrix multiplication can be issued repeatedly when pressing a SW board button. MU (Messaging Unit)erpc transport layer is used in this example application.eRPC documentation eRPC specific files are stored in: middleware/multicore/erpc eRPC documentation is stored in: middleware/multicore/erpc/doc eRPC is open-source project stored on github: https://github.com/EmbeddedRPC/erpc eRPC documentation can be also found in: http://embeddedrpc.github.io</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_matrix_multiply_mu_rtos_cm7.uvprojx"/>
        <environment name="csolution" load="../erpc_matrix_multiply_mu_rtos.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="erpc_matrix_multiply_rpmsg_cm7" folder="boards/evkbmimxrt1170/multicore_examples/erpc_matrix_multiply_rpmsg/cm7" doc="readme.md">
      <description>The Multicore eRPC Matrix Multiply project is a simple demonstration program that uses theMCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Callbetween cores of the multicore system. The primary core (eRPC client) releases the secondary core(eRPC server) from the reset and then the erpcMatrixMultiply() eRPC call is issued to let thesecondary core to perform the multiplication of two randomly generated matrices. The originalmatrices and the result matrix is printed out to the serial console by the primary core. Thematrix multiplication can be issued repeatedly when pressing a SW board button. RPMsg-Lite erpctransport layer is used in this example application.Shared memory usageThis multicore example uses the shared memory for data exchange. The shared memory region isdefined and the size can be adjustable in the linker file. The shared memory region start addressand the size have to be defined in linker file for each core equally. The shared memory startaddress is then exported from the linker to the application.eRPC documentationeRPC specific files are stored in: middleware/multicore_&lt;version&gt;/erpceRPC documentation is stored in: middleware/multicore_&lt;version&gt;/erpc/doceRPC is open-source project stored on github: https://github.com/EmbeddedRPC/erpceRPC documentation can be also found in: http://embeddedrpc.github.io</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_matrix_multiply_rpmsg_cm7.uvprojx"/>
        <environment name="csolution" load="../erpc_matrix_multiply_rpmsg.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="erpc_matrix_multiply_rpmsg_rtos_cm7" folder="boards/evkbmimxrt1170/multicore_examples/erpc_matrix_multiply_rpmsg_rtos/cm7" doc="readme.md">
      <description>The Multicore eRPC Matrix Multiply RTOS project is a simple demonstration program that uses theMCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Callbetween cores of the multicore system. The primary core (eRPC client) releases the secondary core(eRPC server) from the reset and then the erpcMatrixMultiply() eRPC call is issued to let thesecondary core to perform the multiplication of two randomly generated matrices. The originalmatrices and the result matrix is printed out to the serial console by the primary core. Thematrix multiplication can be issued repeatedly when pressing a SW board button. RPMsg-Lite erpctransport layer is used in this example application.Shared memory usageThis multicore example uses the shared memory for data exchange. The shared memory region isdefined and the size can be adjustable in the linker file. The shared memory region start addressand the size have to be defined in linker file for each core equally. The shared memory startaddress is then exported from the linker to the application.eRPC documentationeRPC specific files are stored in: middleware/multicore_&lt;version&gt;/erpceRPC documentation is stored in: middleware/multicore_&lt;version&gt;/erpc/doceRPC is open-source project stored on github: https://github.com/EmbeddedRPC/erpceRPC documentation can be also found in: http://embeddedrpc.github.io</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_matrix_multiply_rpmsg_rtos_cm7.uvprojx"/>
        <environment name="csolution" load="../erpc_matrix_multiply_rpmsg_rtos.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="erpc_two_way_rpc_rpmsg_rtos_cm7" folder="boards/evkbmimxrt1170/multicore_examples/erpc_two_way_rpc_rpmsg_rtos/cm7" doc="readme.md">
      <description>The Multicore eRPC Two Way RPC RTOS project is a simple demonstration program that uses the MCUXpresso SDK software and the Multicore SDK to show how to implement the Remote Procedure Call between cores of the multicore system. This multicore example shows how both the eRPC client and the eRPC server can be setup on one side/core (bidirectional communication) and how to handle callback functions in eRPC. The primary core (Core0) creates client and server tasks first. The client task releases the secondary core from the reset, initializes the RPMsg-Lite erpc transport and once the server task is running it configures the arbitrated client. Then the application logic is running. The secondary core (Core1) creates client and server tasks two. The client task initializes the RPMsg-Lite erpc transport and once the server task is running it configures the arbitrated client. Then the application logic is running. The client task logic of the Core1 is very simple, it repeatedly calls the increaseNumber() erpc function that is implemented on the Core0 and that increments the counter. The client task logic of the Core0 alternately issues either getNumberFromCore0() function implementation on the Core0 or getNumberFromCore1() function implementation on the Core1 (erpc call). Then, the nestedCallGetNumber() erpc function call is issued that alternately triggers either getNumberFromCore1() function implementation on the Core1 (normal erpc call) or it triggers the getNumberFromCore0() function implementation on the Core0 (nested erpc call, routed through the Core1 erpc server).</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/erpc_two_way_rpc_rpmsg_rtos_cm7.uvprojx"/>
        <environment name="csolution" load="../erpc_two_way_rpc_rpmsg_rtos.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="freertos_message_buffers_cm7" folder="boards/evkbmimxrt1170/multicore_examples/freertos_message_buffers/cm7" doc="readme.md">
      <description>The FreeRTOS Message Buffers multicore project is a simple demonstration program that uses the MCUXpresso SDK software and the Message Buffers component of FreeRTOS. It shows how to implement lightweight core to core communication using FreeRTOS Message Buffers, which are lockless circular buffers that can pass data packets of varying sizes from a single sender to a single receiver. The primary core releases the secondary core from the reset and then the inter-core communication is established then. Once the Message Buffers are initialized on both cores the message exchange starts, incrementing a virtual counter that is part of the message payload. The message pingpong finishes when the counter reaches the value of 100. The Message Buffer is deinitialized at the end. NXP Multicore Manager (MCMGR) component is used for several purposes in this example: - it releases the secondary core from the reset (starts the secondary code) - it registers and use the application event for init handshaking (the secondary core application signals to the primary core it is ready to communicate) - it registers and use the FreeRtosMessageBuffersEvent for inter-core interrupts triggering and interrupts handling. Shared memory usage: This multicore example uses the shared memory for data exchange. The shared memory region is defined and the size can be adjustable in the linker file. The shared memory region start address and the size have to be defined in linker file for each core equally. The shared memory start address is then exported from the linker to the application to allow placing FreeRTOS Message Buffers at a fixed location that is then known for both cores.</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/freertos_message_buffers_cm7.uvprojx"/>
        <environment name="csolution" load="../freertos_message_buffers.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="hello_world_cm7" folder="boards/evkbmimxrt1170/multicore_examples/hello_world/cm7" doc="readme.md">
      <description>The Multicore Hello World demo application demonstrates how to set up projects for individualcores on a multicore system. In this demo, the primary core prints the "Hello World from the Primary Core!"string to the terminal and then releases the secondary core from the reset. The secondarycore toggles an on-board LED indicating that the secondary core is running.</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/hello_world_cm7.uvprojx"/>
        <environment name="csolution" load="../hello_world_multicore.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="rpmsg_lite_pingpong_cm7" folder="boards/evkbmimxrt1170/multicore_examples/rpmsg_lite_pingpong/cm7" doc="readme.md">
      <description>The Multicore RPMsg-Lite pingpong project is a simple demonstration program that uses theMCUXpresso SDK software and the RPMsg-Lite library and shows how to implement the inter-corecommunicaton between cores of the multicore system. The primary core releases the secondary corefrom the reset and then the inter-core communication is established. Once the RPMsg is initializedand endpoints are created the message exchange starts, incrementing a virtual counter that is partof the message payload. The message pingpong finishes when the counter reaches the value of 100.Then the RPMsg-Lite is deinitialized and the procedure of the data exchange is repeated again.Shared memory usageThis multicore example uses the shared memory for data exchange. The shared memory region isdefined and the size can be adjustable in the linker file. The shared memory region start addressand the size have to be defined in linker file for each core equally. The shared memory startaddress is then exported from the linker to the application.</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/rpmsg_lite_pingpong_cm7.uvprojx"/>
        <environment name="csolution" load="../rpmsg_lite_pingpong.csolution.yml"/>
      </project>
      <attributes/>
    </example>
    <example name="rpmsg_lite_pingpong_rtos_cm7" folder="boards/evkbmimxrt1170/multicore_examples/rpmsg_lite_pingpong_rtos/cm7" doc="readme.md">
      <description>The Multicore RPMsg-Lite pingpong RTOS project is a simple demonstration program that uses theMCUXpresso SDK software and the RPMsg-Lite library and shows how to implement the inter-corecommunicaton between cores of the multicore system. The primary core releases the secondary corefrom the reset and then the inter-core communication is established. Once the RPMsg is initializedand endpoints are created the message exchange starts, incrementing a virtual counter that is partof the message payload. The message pingpong finishes when the counter reaches the value of 100.Then the RPMsg-Lite is deinitialized and the procedure of the data exchange is repeated again.Shared memory usageThis multicore example uses the shared memory for data exchange. The shared memory region isdefined and the size can be adjustable in the linker file. The shared memory region start addressand the size have to be defined in linker file for each core equally. The shared memory startaddress is then exported from the linker to the application.</description>
      <board name="MIMXRT1170-EVKB" vendor="NXP" Dvendor="NXP:11"/>
      <project>
        <environment name="uv" load="mdk/rpmsg_lite_pingpong_rtos_cm7.uvprojx"/>
        <environment name="csolution" load="../rpmsg_lite_pingpong_rtos.csolution.yml"/>
      </project>
      <attributes/>
    </example>
  </examples>
</package>
